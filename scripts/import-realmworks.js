// Realm Works rwoutput file:
// (only relevant attributes are listed, especially ignoring the uuid attributes)
//
// output(1)  (attrs: format_version, game_system_id, export_date)
// +-- definition(1)
//     +-- details(1) (attrs: name, abbrev)
// +-- contents(1)
//     +-- topic(x)
//         +-- alias(x) (attrs: alias_id, name)
//         +-- section(x) (attrs: name)
//             +-- snippet (attrs: type)
//                 +-- contents (encoded HTML) [for type=="Multi_Line"]
//                 +-- game_date (attrs: canonical, gregorian, display) [for type=="Date_Game"]
//                 +-- date_range (attrs: canonical_start...) [for type=="Date_Range"]
//                 +-- 
//         +-- tag_assign(x) (attrs: tag_name, domain_name)
//         +-- linkage(x) (attrs: target_id, target_name, direction[Inbound|Outbound|Both])

// Nested "section" elements increase the Hx number by one for the section heading.

import "./UZIP.js";
import "./jimp.js";
import { DirectoryPicker } from "./DirectoryPicker.js";

const GS_MODULE_NAME = "realm-works-import";
const GS_CREATE_INBOUND_LINKS = "createInboundLinks";
const GS_CREATE_OUTBOUND_LINKS = "createOutboundLinks";
const GS_FOLDER_NAME = "folderName";
const GS_DELETE_OLD_FOLDERS = "deleteOldFolders";
const GS_UPDATE_EXISTING = "updateExisting";
const GS_ASSETS_LOCATION = "assetsLocation";
const GS_ACTOR_TYPE = "actorType";
const GS_GOVERNING_CONTENT_LABEL = "governingContentLabel";
const GS_GOVERNED_MAX_DEPTH = "governingMaxDepth";

//
// Register game settings
//
Hooks.once('init', () => {
	
	// See API documentation "ClientSettings"
	game.settings.register(GS_MODULE_NAME, GS_ASSETS_LOCATION, {
		name: "Location of Extracted Assets",
		hint: "Folder within [User Data] area where assets (e.g. sounds, PDFs, videos) embedded in the RWoutput file will be placed.",
		scope: "world",
		type:  DirectoryPicker.Directory,
		default: `[data] worlds/${game.world.data.name}/realmworksimport`,
		//filePicker: true,		// 0.8.x onwards, but doesn't let us read FilePicker#source so we can't put it in S3 if chosen
		config: true,
	});
	let actors = {};
	for (let label of game.system.entityTypes.Actor) {
		actors[label] = label
	}
	// Get the list of Actor choices Actor.types[] system/template.json
    game.settings.register(GS_MODULE_NAME, GS_ACTOR_TYPE, {
		name: "Default Actor Type",
		hint: "When a statblock is encountered in the RW/HL file, an Actor of this type will be created",
		scope: "world",
		type:  String,
		choices: actors,
		default: game.system.entityTypes.Actor[0],
		config: true,
	});
    game.settings.register(GS_MODULE_NAME, GS_GOVERNING_CONTENT_LABEL, {
		name: "Governing Content Label",
		hint: "The label to appear to identify the link to a parent Journal Entry",
		scope: "world",
		type:  String,
		default: 'Governing Content: ',
		config: true,
	});
    game.settings.register(GS_MODULE_NAME, GS_GOVERNED_MAX_DEPTH, {
		name: "Max Depth for Governing Content",
		hint: "The maximum depth of ancestors to be displayed in a journal entry's governed content hierarchy (0 = do not include governed content",
		scope: "world",
		type:  Number,
		default: 99,
		config: true,
	});
/*	
	JavaScript doesn't allow us to access the PATH of a File object,
	so we can't save the full path to the RWoutput file for next use.
	game.settings.register(GS_MODULE_NAME, "sourceFile", {
		name: "The RWoutput file to be processed",
		hint: "The RWoutput file generated by Realm Works to be imported",
		scope: "world",
		type:  File,
		default: '',
		config: false,
	});*/
    game.settings.register(GS_MODULE_NAME, GS_CREATE_INBOUND_LINKS, {
		name: "Create Inbound Links",
		hint: "Creates a section at the bottom of each journal entry indicating inbound links from other journal entries",
		scope: "world",
		type:  Boolean,
		default: true,
		config: false,
	});
    game.settings.register(GS_MODULE_NAME, GS_CREATE_OUTBOUND_LINKS, {
		name: "Create Outbound Links",
		hint: "Creates a section at the bottom of each journal entry indicating outbound links to other journal entries",
		scope: "world",
		type:  Boolean,
		default: true,
		config: false,
	});
    game.settings.register(GS_MODULE_NAME, GS_FOLDER_NAME, {
		name: "Folder Name",
		hint: "The name of the folder which will be created in each part of the world data areas to contain the things imported from the RWoutput file",
		scope: "world",
		type:  String,
		default: "Realm Works",
		config: false,
	});
    game.settings.register(GS_MODULE_NAME, GS_DELETE_OLD_FOLDERS, {
		name: "Delete Existing Folders",
		hint: "Delete any existing folders with the Folder Name. Useful when re-importing data",
		scope: "world",
		type:  Boolean,
		default: true,
		config: false,
	});
    game.settings.register(GS_MODULE_NAME, GS_UPDATE_EXISTING, {
		name: "Updating Existing Entries",
		hint: "When not deleting old folders, update any entries found with the same name rather than creating new entries",
		scope: "world",
		type:  Boolean,
		default: false,
		config: false,
	});
})


// Provide hook to put the button at the bottom of the COMPENDIUM panel in Foundry VTT
// Set up the user interface

Hooks.on("renderSidebarTab", async (app, html) => {
    if (app.options.id === "compendium") {
      let button = $("<button class='import-cd'><i class='fas fa-file-import'></i> Realm Works Import</button>")
      button.click(function () {
        new RealmWorksImporter().render(true);
      });
      
      html.find(".directory-header").append(button);
    }
})


class RealmWorksImporter extends Application
{
	// entity_for_topic is a map: key = topic_id, value = JournalEntry
	
	// Foundry VTT default options for the dialogue window,
	// note that we supply the HTML file that will show the window.
	static get defaultOptions()
	{
		const options = super.defaultOptions;
		options.id = "realm-works-importer";
		options.template = "modules/realm-works-import/templates/import_ui.html";
		options.classes.push("realm-works-importer");
		options.resizable = false;
		options.height = "auto";
		options.width = 400;
		options.minimizable = true;
		options.title = "Realm Works Importer";
		return options;
	}

	// Foundry VTT listener for actions in the window.
	activateListeners(html) {
		super.activateListeners(html);
		
		// Set stored values for each field
		html.find('[name=folder-name]')?.val(                 game.settings.get(GS_MODULE_NAME, GS_FOLDER_NAME));
		html.find('[name=inboundLinks]')?.prop('checked',     game.settings.get(GS_MODULE_NAME, GS_CREATE_INBOUND_LINKS));
		html.find('[name=outboundLinks]')?.prop('checked',    game.settings.get(GS_MODULE_NAME, GS_CREATE_OUTBOUND_LINKS));
		html.find('[name=deleteOldFolders]')?.prop('checked', game.settings.get(GS_MODULE_NAME, GS_DELETE_OLD_FOLDERS));
		html.find('[name=updateExisting]')?.prop('checked',   game.settings.get(GS_MODULE_NAME, GS_UPDATE_EXISTING));
		//html.find('[name=folder-name]')?.val(game.settings.get(GS_MODULE_NAME, 
		
		html.find(".import-rwoutput").click(async ev => {
			this.folderName = html.find('[name=folder-name]').val();
			this.ui_message = html.find('[name=message-area]');
			this.addInboundLinks = html.find('[name=inboundLinks]').is(':checked');
			this.addOutboundLinks = html.find('[name=outboundLinks]').is(':checked');
			this.deleteOldFolders = html.find('[name=deleteOldFolders]').is(':checked');

			// Ensure folder name is present.
			if (this.folderName.length === 0) {
				this.ui_message.val('Folder name is missing!');
				return;
			}
			
			// Set the correct function to use based on the game system
			this.actor_type = game.settings.get(GS_MODULE_NAME, GS_ACTOR_TYPE);
			this.governing_content_label = game.settings.get(GS_MODULE_NAME, GS_GOVERNING_CONTENT_LABEL);
			this.governed_max_depth = game.settings.get(GS_MODULE_NAME, GS_GOVERNED_MAX_DEPTH);
			
			switch (game.system.id) {
			case 'pf1':
				this.actor_data_func = function(html) { return { details: { notes: { value: html }}} };
				let {default:RWPF1Actor} = await import("./actor-pf1.js");
				this.init_actors = RWPF1Actor.initModule;
				this.create_actor_data = RWPF1Actor.createActorData;
				break;

			case 'dnd5e':
				this.actor_data_func = function(html) { return { details: { biography: { value: html }}} };
				let {default:RWDND5EActor} = await import("./actor-dnd5e.js");
				this.init_actors = RWDND5EActor.initModule;
				this.create_actor_data = RWDND5EActor.createActorData;
				break;
				
			case 'swade':
				this.actor_data_func = function(html) { return { details: { biography: { value: html }}} };
				let {default:RWSWADEActor} = await import("./actor-swade.js");
				this.init_actors = RWSWADEActor.initModule;
				this.create_actor_data = RWSWADEActor.createActorData;
				break;
				
			case 'pf2e':
				this.actor_data_func = function(html) { return { details: { biography: { value: html }}} };
				break;
				
			case 'grpga':
				this.actor_data_func = function(html) { return { biography: html }};
				break;
				
			case 'wfrp4e':
				this.actor_data_func = function(html) { return { details: { biography: { value: html }}} };
				break;
				
			case 'CoC7':
				// CoC7 shows raw HTML code, not formatted
				this.actor_data_func = function(html) { return { biography: { personalDescription: { value: html }}} };
				break;
				
			case 'pbta':
				// Creates error "One of original or other are not Objects!"
				this.actor_data_func = function(html) { return { details: { biography: html }} };
				break;

			case 'alienrpg':
				// This system doesn't have a biography/notes section on the Actor sheet
				this.actor_data_func = function(html) { return { notes: html } };
				break;
				
			case 'worldbuilding':
				this.actor_data_func = function(html) { return { biography: html } };
				break;
			
			case 'cyphersystem':
				if (this.actor_type === 'PC')
					this.actor_data_func = function(html) { return { basic: { notes: html }} };
				else
					this.actor_data_func = function(html) { return { description: html } };
				break;
			
			default:
				this.actor_data_func = function(html) { return { biography: { personalDescription: { value: html }}} };
				break;
			} // switch (game.system.id)
			
			// Save the selections.
			game.settings.set(GS_MODULE_NAME, GS_CREATE_INBOUND_LINKS,  this.addInboundLinks);
			game.settings.set(GS_MODULE_NAME, GS_CREATE_OUTBOUND_LINKS, this.addOutboundLinks);
			game.settings.set(GS_MODULE_NAME, GS_FOLDER_NAME,           this.folderName);
			game.settings.set(GS_MODULE_NAME, GS_DELETE_OLD_FOLDERS,    this.deleteOldFolders);
			//game.settings.set(GS_MODULE_NAME, GS_UPDATE_EXISTING, ); // not implemented yet
			
			// Where image files should be stored...
			this.asset_directory = game.settings.get(GS_MODULE_NAME, GS_ASSETS_LOCATION);		// no trailing "/"
			const options = DirectoryPicker.parse(this.asset_directory);
			// Create the prefix when referencing the location of uploaded files
			if (options.activeSource === 's3')
				this.asset_url = game.data.files.s3.endpoint.protocol + '//' + options.bucket + '.' +
					game.data.files.s3.endpoint.hostname + '/' + options.current + '/';
			else
				this.asset_url = options.current + '/';
			
			// Try to load the file
			let fileinput = html.find('[name=rwoutputFile]')?.[0];
			if (!fileinput?.files || fileinput.files.length === 0)
			{
				this.ui_message.val(`Please select a file.`);
				return;
			}
			let file = fileinput.files[0];
			
			this.ui_message.val(`Reading ${file.name}`);
			console.info(`Reading contents of ${file.name} (size ${file.size})`);
			
			if (file.name.endsWith('.por')) {
				console.info(`Parsing HeroLab Portfolio file`);
				await this.parseHL(file);
				console.info('******  Finished  ******');
				this.ui_message.val('--- Finished ---');
				fileinput = undefined;
				file = undefined;
				return;
			}

			if (!this.parser) this.parser = new DOMParser();
			
			// Javascript string has a maximum size of 512 MB, so can't pass the entire file to parseFromString,
			// so read chunks of the file and look for topics within the chunks.
			const chunkSize = 5000000;	// ~5 MB
			let buffer = "";
			let topic_nodes = [];
			let start = 0;
			let first=true;
			while (start < file.size) {
				// Read another chunk onto the end of the buffer.
				const blob = await file.slice(start, start+chunkSize);
				if (blob.size === 0) break;
				start += blob.size;
				buffer += await blob.text();
				
				// Strip leading space before the first <topic> to help keep the size of buffer relatively small
				if (first) {
					let pos = buffer.indexOf('<topic ');
					if (pos < 0) continue;		// We haven't found the first topic yet
					buffer = buffer.slice(pos);
					first = false;
				}

				console.debug(`Read ${blob.size} bytes from file (buffer size now ${buffer.length}`);
				// Read all complete topics which are in the buffer
				while (true) {
					// Firstly, find first end-of-topic marker
					const topic_end = buffer.indexOf('</topic>');
					if (topic_end < 0) break;
					// Find the start-of-topic marker for that end-marker
					const topic_start = buffer.lastIndexOf('<topic ', topic_end);
					if (topic_start < 0) break;
					//let docnode = this.parser.parseFromString('<?xml version="1.0" encoding="utf-8"?>' + buffer.slice(topic_start, topic_end+8), "text/xml");
					const block = buffer.slice(topic_start, topic_end+8);
					try {
						// parseFromString returns a #Document node as the top node.
						const topicnode = this.getChild(this.parser.parseFromString(block, "text/xml"), 'topic');
						if (topicnode) {
							topic_nodes.push(topicnode);
							// Replace extracted topic with a marker to correctly identify child topics.
							// Ensure topics with " in the title don't cause problems
							buffer = buffer.slice(0,topic_start) + 
								`<topicchild topic_id="${topicnode.getAttribute('topic_id')}" public_name="${topicnode.getAttribute('public_name').replace(/"/g,'%22')}" />` + 
								buffer.slice(topic_end+8);
						} else {
							console.warn(`Failed to decode topic in ${block}`);
							// Remove offending topic without marker
							buffer = buffer.slice(0,topic_start) + buffer.slice(topic_end+8);
						}
					} catch(e) {
						console.warn(`Parsing failed due to ${e}`);
						console.warn(`text: ${block}`);
						// Remove offending topic without marker
						buffer = buffer.slice(0,topic_start) + buffer.slice(topic_end+8);
					}
				}
			}
			// Collect parent information
			let parent_map = new Map();
			let child_map = new Map();
			for (let topic of topic_nodes) {
				let parent_id = topic.getAttribute('topic_id');
				for (let child of topic.getElementsByTagName('topicchild')) {
					const child_id = child.getAttribute('topic_id');
					parent_map.set(child_id, parent_id);
					if (!child_map.has(parent_id))
						child_map.set(parent_id, [child_id]);
					else
						child_map.get(parent_id).push(child_id);	// append to end of array
				}
			}
			
			// Do the actual work!
			console.info(`Found ${topic_nodes.length} topics and ${parent_map.size} parents`);
			await this.parseXML(topic_nodes, parent_map, child_map);
			
			console.info('******  Finished  ******');
			this.ui_message.val('--- Finished ---');
			
			// Release all memory
			fileinput = undefined;
			file = undefined;
			buffer = undefined;
			topic_nodes = undefined;
			parent_map.clear();
			child_map.clear();
			
			// Automatically close the window after the import is finished
			//this.close();
		});
	}

	async getFolder(folderName, type, parentid=null) {
		// Need to check PARENT as well!
		const found = game.folders.filter(e => e.type === type && e.name === folderName && e.parent === parentid);
		if (found?.length > 0)
			return found[0];
		else
			return await Folder.create({name: folderName, type: type, parent: parentid});
	}
	
	// Generic routine to create any type of inter-topic link (remote_link can be undefined)
	formatLink(topic_id, link_name) {
		const id = this.entity_for_topic[topic_id]?.data._id;
		if (id)
			return `@JournalEntry[${id}]{${link_name}}`;
		else
			return `@JournalEntry[${link_name}]`;
	}
	
	//
	// Convert Utf8Array to UTF-8 string
	//
	Utf8ArrayToStr(array) {
		let out, i, len, c;
		let char2, char3;

		out = "";
		len = array.length;
		i = 0;
		while(i < len) {
			c = array[i++];
			switch(c >> 4)
			{ 
			case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
				// 0xxxxxxx
				out += String.fromCharCode(c);
				break;
			case 12: case 13:
				// 110x xxxx   10xx xxxx
				char2 = array[i++];
				out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
				break;
			case 14:
				// 1110 xxxx  10xx xxxx  10xx xxxx
				char2 = array[i++];
				char3 = array[i++];
				out += String.fromCharCode(((c & 0x0F) << 12) |
							((char2 & 0x3F) << 6) |
							((char3 & 0x3F) << 0));
				break;
			}
		}
		return out;
	}
	// If the paragraph contains only a single Realm Works paragraph+span, then replace with a simple paragraph
	// Strip <p class="RWDefault"><span class="RWSnippet">...</span></p> from the supplied text
	stripPara(original) {
		const prefix = '<p class="RWDefault"><span class="RWSnippet">';
		const suffix = '</span></p>';
		if (original.startsWith(prefix) && original.endsWith(suffix)) {
			const result = original.slice(prefix.length, -suffix.length);
			// Don't do it if there is another paragraph in the middle
			if (!result.includes('<p')) return result;
		}
		return original;
	}
	// Strip all HTML from the string.
	stripHtml(original) {
		return original.replace(/<[^>]+>/g, '');
	}
	
	// Remove the default class information from the RW formatting to reduce the size of the final HTML.
	simplifyPara(original) {
		// Too much effort to remove <span> and </span> tags, so just simplify.
		return original.replace(/<p class="RWDefault">/g,'<p>').replace(/<span class="RWSnippet">/g,'<span>');
	}

	// Some image files are changed to .png (from .bmp .tif .tiff)
	validfilename(filename) {
		if (filename.endsWith('.bmp') || filename.endsWith('.tif'))
			return filename.slice(0,-4) + '.png';
		else if (filename.endsWith('.tiff'))
			return filename.slice(0,-5) + '.png';
		else
			return filename;
	}
	
	imageFilename(filename) {
		return this.asset_url + this.validfilename(filename);
	}

	// Upload the specified binary data to a file in this.asset_directory
	async uploadBinaryFile(filename, srcdata) {
		let data = srcdata;
		if (filename.endsWith('.bmp') || filename.endsWith('.tif') || filename.endsWith('.tiff'))
		{
			data = await Jimp.read(Buffer.from(srcdata)).then(image => image.getBufferAsync('image/png'));
		}
		// data = base64 string
		const file = new File([data], this.validfilename(filename));
		await DirectoryPicker.uploadToPath(this.asset_directory, file)
			//.then(console.debug(`Uploaded file ${filename}`))
			.catch(e => console.warn(`Failed to upload ${filename}: ${e}`));
	}

	// Convert a string in base64 format into binary and upload to this.asset_directory,
	async uploadFile(filename, base64) {
		await this.uploadBinaryFile(filename, Uint8Array.from(atob(base64), c => c.charCodeAt(0)) );
	}

	// Convert a Smart_Image into a scene
	async createScene(topic_id, smart_image) {
		//<snippet facet_name="Map" type="Smart_Image" search_text="">
		//  <smart_image name="Map">
		//    <asset filename="n5uvmpam.eb4.png">
		//      <contents>
		//	  <map_pin pin_name="Deneb Sector" topic_id="Topic_392" x="330" y="239">	-- topic_id is optional
		//		<description>Nieklsdia (Zhodani)</description> -- could be empty

		// These need to be created as Scenes (and linked from the original topic?)
		//const scenename = smart_image.parentElement?.getAttribute('facet_name');
		const asset    = this.getChild(smart_image, 'asset'); // <asset filename="10422561_10153053819388385_8373621707661700909_n.jpg">
		const contents = this.getChild(asset, 'contents'); // <contents>
		const filename = asset?.getAttribute('filename');
		if (!asset)	throw('<smart_image> is missing <asset>');
		if (!contents) throw('<smart_image> is missing <contents>');
		if (!filename) throw('<smart_image><asset> is missing filename attribute');
		
		// Name comes from topic name + facet_name
		const scenename = this.topic_names.get(topic_id) + ':' + smart_image.getAttribute('name');
		//console.debug(`smart_image: scene name = ${scenename} from topic_id ${topic_id}`);
	
		// Firstly, put the file into the files area.
		//const imgname = await this.uploadFile(asset.getAttribute('filename'), contents.textContent);
		
		// The file was uploaded when the TOPIC was processed, so can simply read it here.
		const imagename = this.imageFilename(filename);
		const tex = await loadTexture(imagename);	// when previously uploaded, bmp/tif/tiff files were converted to png.
		let scenedata = {
			name   : scenename,
			img    : imagename,
			folder : this.scene_folder.id,
			active : false,
			navigation: false,
			width  : tex.baseTexture.width,
			height : tex.baseTexture.height,
			padding: 0,
		};
		if (topic_id) scenedata.journal = this.entity_for_topic[topic_id]?.data._id;
		
		// Delete the old scene by the same name
		let oldscene = game.scenes.find(p => p.name === scenename);
		if (oldscene) {
			this.ui_message.val(`Deleting old scene ${scenename}`);
			console.debug(`Deleting old scene ${scenename}`);
			await oldscene.delete();
		}

		//console.debug(`Creating scene in folder ${scenedata.folder}`);
		let scene = await Scene.create(scenedata)
			.catch(e => console.warn(`Failed to created scene for '${scenename}' with image '${scenedata.img}' due to ${e}`));
		//if (scene) console.debug(`Successfully created scene for ${scenename} in folder ${scene.folder}`);
		if (!scene) return;
		
		// Create thumbnail
		scene.createThumbnail().then(data => scene.update({thumb: data.thumb}));
		
		// Add some notes
		for (const pin of smart_image.getElementsByTagName('map_pin')) {
			const pinname = pin.getAttribute('pin_name');
			let desc = pin.getElementsByTagName('description')[0]?.textContent;
			let gmdir = pin.getElementsByTagName('gm_directions')?.[0]?.textContent;
			let entryid = this.entity_for_topic[pin.getAttribute('topic_id')]?.data._id;
			let label = '';
			if (desc.length > 0) label += '\n' + desc.replace('&#xd;\n','\n');
			if (gmdir) label += '\nGMDIR: ' + gmdir.replace('&#xd;\n','\n');
			// Embellish title if there is more to follow in the note
			if (label.length === 0) 
				label = pinname;
			else
				label = '**' + pinname + '**' + label;
			
			let notedata = {
				name: pinname,
				entryId: entryid,
				x: pin.getAttribute('x'),
				y: pin.getAttribute('y'),
				icon: 'icons/svg/circle.svg',		// Where do we get a good icon?
				iconSize: 32,		// minimum size 32
				iconTint: entryid ? '#7CFC00' : '#c00000',
				text: label,
				fontSize: 24,
				//textAnchor: CONST.TEXT_ANCHOR_POINTS.CENTER,
				//textColor: "#00FFFF",
				scene: scene.id,
			};
			await scene.createEmbeddedDocuments('Note', [notedata]);
			
			//if (note) console.debug(`Created map pin ${notedata.name}`);
		}
		this.ui_message.val(`Created scene '${scenename}'`);
		console.debug(`Created scene '${scenename}'`);
		return scene.id;
	}
		
	// Returns the named direct child of node.  node can be undefined, failure to find will return undefined.
	getChild(node,name) {
		if (node) {
			// children   = only element children
			// childNodes = all child nodes
			for (const child of node.children) {
				if (child.nodeName === name) return child;
			}
		}
		return undefined;
	}

	// base64 is the base64 string containing the .por file
	// format is one of the character formats in the .por file: 'html', 'text', 'xml' (need to do this.Utf8ArrayToStr to get to string)
	// Returns an array of [ name , data ] for each character/minion in the portfolio.
	
	readPortfolio(data) {
		const buf = (data instanceof Uint8Array) ? data : Uint8Array.from(atob(data), c => c.charCodeAt(0));
		const files = UZIP.parse(buf);
		// Now have an object with "key : property" pairs  (key = filename [String]; property = file data [Uint8Array])

		// Process the index.xml in the root of the portfolio file.
		if (!this.parser) this.parser = new DOMParser();
		const xmlDoc = this.parser.parseFromString(this.Utf8ArrayToStr(files['index.xml']),"text/xml");
		// <document><characters>
		//   <character name="Fantastic">
		//    <statblocks><statblock format="html" folder="statblocks_html" filename="1_Fantastic.htm"/>
		//    <images><image>
		//    <minions><character name="Flappy"> <summary><statblocks><statblock format="html" folder="statblocks_html" filename="1_Fantastic.htm"/>
		
		// For each character in the POR, extract the statblock with the corresponding format, and any minions with the corresponding statblock
		let result = new Map();
		for (const character of xmlDoc.getElementsByTagName('character')) {
			let actordata = { name: character.getAttribute('name') };
			if (!actordata.name) {
				console.warn(`No 'name' tag in character portfolio: fields = ${character.getAttributeNames()}`);
				continue;
			}
			for (const statblock of this.getChild(character,'statblocks').children) {
				if (statblock.nodeName === 'statblock') {
					const format = statblock.getAttribute('format');
					const folder = statblock.getAttribute('folder');
					const filename = statblock.getAttribute('filename');
					actordata[format] = files[folder + '/' + filename];
				}
			}
			const img  = this.getChild(this.getChild(character,'images'),'image');
			if (img) {
				const folder   = img.getAttribute('folder');
				const filename = img.getAttribute('filename');
				actordata.imgfilename = filename;
				actordata.imgdata = files[folder + '/' + filename];
			}
			result.set(actordata.name, actordata);
		}
		//console.info(`...found ${result.length} sheets`);
		return result;
	}

	// 
	// Convert the XML read from a portfolio file into an Object hierarchy
	//
	static xmlToObject(xmlDoc, arrayTags) {

		function parseNode(xmlNode, result) {
			if (xmlNode.nodeName === "#text") {
				let v = xmlNode.nodeValue;
				if (v.trim())
					result['#text'] = v;
				return;
			}
			let jsonNode = {},
			existing = result[xmlNode.nodeName];
			if (existing) {
				if (!Array.isArray(existing))
					result[xmlNode.nodeName] = [existing, jsonNode];
				else
					result[xmlNode.nodeName].push(jsonNode);
			} else {
				if (arrayTags && arrayTags.indexOf(xmlNode.nodeName) !== -1)
					result[xmlNode.nodeName] = [jsonNode];
				else
					result[xmlNode.nodeName] = jsonNode;
			}
			if (xmlNode.attributes) {
				for (let attribute of xmlNode.attributes) {
					jsonNode[attribute.nodeName] = attribute.nodeValue;
				}
			}
			for (let node of xmlNode.childNodes) {
				parseNode(node, jsonNode);
			}
		}
		let result = {};
		for (let node of xmlDoc.childNodes) {
			parseNode(node, result);
		}
		return result;
	}


	//
	// Write one RW section
	//
	async writeSection(this_topic_id, section, level, linkage_names) {

		// We can't access "this" inside the replaceLinks function
		let functhis = this;
		
		// Write a "contents" element:
		// Only <contents> can contain <span> which identify links.
		function replaceLinks(original, linkage_names) {
			// Replace '<scan>something</scan>' with '@JournalEntry[<topic-for-something>]{something}'
			// RW v267 might also use '<scan class="RWSnippet">something</scan>' for links, which is the same as for normal paragraphs!
			// @JournalEntry is case sensitive when using names!
			return original.replace(/(<span[^>]*>)([^<]+)<\/span>/g,
				function (match, p1, p2, offset, string) {
				for (const [topic_id, labels] of linkage_names) {
					// case insensitive search across all entries in the Array() stored in the map.
					if (labels.some(item => (item.localeCompare(p2, undefined, { sensitivity: 'base' }) === 0))) {
						return functhis.formatLink.call(functhis, topic_id, p2);
					}
				};
				// Not found in map, so just create a broken link for <span>, since we're fairly sure that's what it is.
				// Whereas <span class="RWSnippet"> is just regular text everywhere!
				if (p1 === '<span>')
					return functhis.formatLink.call(functhis, undefined, p2);
				else
					return p1 + p2 + '</span>';
			});
		}
		function header(lvl, name) {
			return `<h${lvl}>${name}</h${lvl}>`;
		}
		
		// Process all the snippets and sections in order
		let result = header(level, section.getAttribute("name"));
		let subsections = "";
		
		// Process all child (not descendent) nodes in this section
		for (const child of section.children) {
			switch (child.nodeName) {
			case 'section':
				// Subsections increase the HEADING number,
				// but need to be buffered and put into the output AFTER the rest of the contents for this section.
				subsections += await this.writeSection(this_topic_id, child, level+1, linkage_names);
				break;
				
			case 'snippet':
				// Snippets contain the real information!
				const sntype = child.getAttribute('type');
				const style  = child.getAttribute('style');
				const contents   = this.getChild(child, 'contents');
				const gmdir      = this.getChild(child, 'gm_directions');
				const annotation = this.getChild(child, 'annotation');
				const label = child.getAttribute('facet_name') ?? child.getAttribute('label');
				
				// If both gmdir and contents, then need an extra border
				let in_section = false;
				let margin="";
				let bgcol="";
				if (gmdir && contents) {
					margin = 'border:1px solid black;margin-top:2px;margin-bottom:2px;';
					in_section = true;
				}
				if (style && style !== 'Normal') {
					if (style === 'Read_Aloud') { // 209,223,242
						bgcol = 'background-color:#d1dff2;padding:1px;';
						in_section = true;
					} else if (style === 'Handout') { // 232,225,217
						bgcol = 'background-color:#e8e1d9;padding:1px;';
						in_section = true;
					} else if (style === 'Flavor') {  // 239,212,210
						bgcol = 'background-color:#efd4d2;padding:1px;';
						in_section = true;
					} else if (style === 'Callout') { // 190,190,190
						bgcol = 'background-color:#bebebe;padding:1px;';
						in_section = true;
					}
				}
				if (in_section) {
					result += '<section style="' + margin + bgcol + '">';
					in_section = true;
				}
				if (gmdir) {
					result += '<section class="secret">' + this.simplifyPara(replaceLinks(gmdir.textContent, linkage_names)) + '</section>';
				}
				
				switch (sntype) {
				case "Multi_Line":
					if (contents) {
						result += this.simplifyPara(replaceLinks(contents.textContent, linkage_names));
					}
					break;
				case "Labeled_Text":
					if (contents) {
						// contents child (it will already be in encoded-HTML)
						result += `<p><b>${label}:</b> ` + this.stripPara(replaceLinks(contents.textContent, linkage_names));
						if (annotation) result += `; <i>${this.stripHtml(annotation.textContent)}</i>`
						result += `</p>`;
					}
					break;
				case "Numeric":
					if (contents) {
						// contents will hold just a number
						result += `<p><b>${label}:</b> ` + replaceLinks(contents.textContent, linkage_names);
						if (annotation) result += `; <i>${this.stripHtml(annotation.textContent)}</i>`
						result += `</p>`;
					}
					break;
				case "Tag_Standard":
					// <tag_assign tag_name="Manufacturing" domain_name="Commerce Activity" type="Indirect" />
					let tags = [];
					for (const snip of child.children) {
						if (snip.nodeName === 'tag_assign') {
							let tag = snip.getAttribute('tag_name');
							if (tag) tags.push(tag);
						}
					}
					result += `<p><b>${label}:</b> `;
					if (tags.length > 0) result += tags.join(', ');
					if (annotation) result += `; <i>${this.stripHtml(annotation.textContent)}</i>`;
					result += `</p>`;
					break;
					
				case "Tag_Multi_Domain":
					let tagmulti = [];
					for (const snip of child.children) {
						if (snip.nodeName === "tag_assign") {
							if (snip.hasAttribute('tag_name')) {
								tagmulti.push(snip.getAttribute('domain_name') + ': ' + snip.getAttribute('tag_name'));
							}
						}
					}
					result += `<p><b>${label}:</b> `;
					if (tagmulti.length > 0) result += tagmulti.join('; ');
					if (annotation) result += `; <i>${this.stripHtml(annotation.textContent)}</i>`;
					result += `</p>`;
					break;
					
				case "Date_Game":
					let gamedate = this.getChild(child, 'game_date');
					result += `<p><b>${label}:</b> `;
					if (gamedate) result += gamedate.getAttribute("display");
					if (annotation) result += `; <i>${this.stripHtml(annotation.textContent)}</i>`;
					result += `</p>`;
					// annotation
					break;
				case "Date_Range":
					let daterange = this.getChild(child, 'date_range');
					result += `<p><b>${label}:</b> `;
					if (daterange) result += `${daterange.getAttribute("display_start")} to ${daterange.getAttribute("display_end")}`;
					if (annotation) result += `; <i>${this.stripHtml(annotation.textContent)}</i>`;
					result += `</p>`;
					// annotation
					break;
				case "Portfolio":
					// <ext_object ...>
					// <asset filename="10422561_10153053819388385_8373621707661700909_n.jpg">
					// <contents>
					let portasset = this.getChild(this.getChild(child, 'ext_object'), 'asset');
					const portfolio = this.getChild(portasset, 'contents');    // <contents>
					if (portfolio) {
						// TODO: for test purposes, extract all .por files!
						//await this.uploadFile(portasset.getAttribute('filename'), portfolio.textContent);
						let first=true;
						for (let [charname, character] of this.readPortfolio(portfolio.textContent)) {
							if (first) { result += '<hr>'; first=false }
							result += header(level+1, character.name) + this.Utf8ArrayToStr(character.html);
						}
					}
					break;
				case "Picture":
				case "PDF":
				case "Audio":
				case "Video":
				case "Statblock":
				case "Foreign":
				case "Rich_Text":
					// <ext_object name="Portrait" type="Picture">
					// <asset filename="10422561_10153053819388385_8373621707661700909_n.jpg">
					// <contents>
					const bin_ext_object = this.getChild(child,          'ext_object');  
					const bin_asset      = this.getChild(bin_ext_object, 'asset');       
					const bin_contents   = this.getChild(bin_asset,      'contents');    
					if (bin_contents) {
						result += header(level+1, bin_ext_object.getAttribute('name'));
						const bin_filename = bin_asset.getAttribute('filename');
						const fileext = bin_filename.split('.').pop();	// extra suffix from asset filename
						if (fileext === 'html' || fileext === 'htm' || fileext === "rtf")
							result += atob(bin_contents.textContent);
						else if (sntype === "Picture") {
							//result += `<p><img src="data:image/${fileext};base64,${bin_contents.textContent}"></img></p>`;
							await this.uploadFile(bin_filename, bin_contents.textContent);
							result += `<p><img src='${this.imageFilename(bin_filename)}'></img></p>`;
						} else {
							let format = 'binary/octet-stream';
							if (fileext === 'pdf') {
								format = 'application/pdf';
							}
							//result += `<p><a href="data:${format};base64,${bin_contents.textContent}"></a></p>`;
							await this.uploadFile(bin_filename, bin_contents.textContent);
							result += `<p><a href='${this.imageFilename(bin_filename)}'></a></p>`;
						}
					}
					break;
				case "Smart_Image":
					//<snippet facet_name="Map" type="Smart_Image" search_text="">
					//  <smart_image name="Map">
					//    <asset filename="n5uvmpam.eb4.png">
					//      <contents>
					//	  <map_pin pin_name="Deneb Sector" topic_id="Topic_392" x="330" y="239">	-- topic_id is optional
					//		<description>Nieklsdia (Zhodani)</description> -- could be empty
					
					// These need to be created as Scenes (and linked from the original topic?)
					const smart_image  = this.getChild(child,       'smart_image');
					const map_asset    = this.getChild(smart_image, 'asset'); 	    // <asset filename="10422561_10153053819388385_8373621707661700909_n.jpg">
					const map_contents = this.getChild(map_asset,       'contents');  	// <contents>
					const map_filename = map_asset?.getAttribute('filename');
					const map_format   = map_filename?.split('.').pop();	// extra suffix from asset filename
					if (map_format && map_contents) {
						result += header(level+1, smart_image.getAttribute('name'));
						//result += `<p><img src="data:image/${map_format};base64,${map_contents.textContent}"></img></p>`;
						await this.uploadFile(map_filename, map_contents.textContent);
						result += `<p><img src='${this.imageFilename(map_filename)}'></img></p>`;

						// Create the scene now
						const sceneid = await this.createScene(this_topic_id, smart_image).catch(e => console.warn(`Failed to create scene for ${topic.name} due to ${e}`));
						result += `<p>@Scene[${sceneid}]{${smart_image.getAttribute('name')}}</p>`;
					}
					break;
				case "tag_assign":
					// Nothing to done for these
					break;
				default:
					console.warn(`Unsupported snippet type: ${sntype}`);
				} // switch sntype
				
				if (in_section) {
					result += '</section>';
				}
				break;

			default:
				if (!child.nodeName.startsWith('#text')) {
					// We can safely ignore whitespace at this level.
					// Some other element type which we haven't implemented yet
					console.warn(`Unsupported element type: ${child.nodeName}`);
				}
			}	// switch child.nodeName
		} // for children
		
		// Now that we've handled all the others snippets, we can append any found subsections.
		result += subsections;
		
		return result;
	}

	//
	// Write one RW topic
	//
	async formatOneTopic(topic, child_map, parent_id) {
		//console.debug(`formatOneTopic('${topic.getAttribute("public_name")}', ${child_map}, ${parent_id}`);

		// Extract only the links that we know are in this topic (if any).
		// Collect linkage children and create an alias/title-to-topic map:
		//   <linkage target_id="Topic_345" target_name="Air/Raft" direction="Outbound" />
		let linkage_names = new Map();
		for (const node of topic.children) {
			if (node.nodeName === "linkage" && node.getAttribute('direction') !== 'Inbound') {
				const target_id = node.getAttribute('target_id');
				// In partial output, all linkages are reported even if the target topic is not present.
				if (this.topic_names.has(target_id)) {
					linkage_names.set(target_id, this.topic_names.get(target_id));
				}
			}
		}
		// Add self to the mapping (in case a topic links to itself, but differs only in case)
		const this_topic_id = topic.getAttribute('topic_id');
		if (this.topic_names.has(this_topic_id)) {
			linkage_names.set(this_topic_id, this.topic_names.get(this_topic_id));
		}
		// Start the HTML with a link to the parent (if known)
		let html = "";
		if (parent_id) {
			html += '<p><b>' + this.governing_content_label + '</b>' + this.formatLink(parent_id, this.topic_names.get(parent_id)) + '</p>';
		}
		
		let functhis = this;
		function addDescendents(depth, top_id) {
			let result = "";
			if (depth < 1 || !child_map.has(top_id)) return result;
			for (const child_id of child_map.get(top_id)) {
				result += '<li>' + functhis.formatLink(child_id, functhis.topic_names.get(child_id)) + addDescendents(depth-1, child_id) + '</li>';
			}
			return `<ul>${result}</ul>`;
		}
		
		// Generate the HTML for the sections within the topic
		let inbound = [];
		let outbound = [];
		let both = [];
		let has_child_topics = false;
		let has_connections = false;
		for (const node of topic.children) {
			switch (node.nodeName) {
			case 'alias':
				// These come first
				html += `<p><b>Alias: </b><i>${node.getAttribute('name')}</i></p>`;
				break;
			case 'section':
				html += await this.writeSection(this_topic_id, node, 1, linkage_names); // Start with H1
				break;
			case 'topicchild':
			case 'topic':
				// No need to handle nested topics, since we found all of them at the start.
				// Put link to child topic in original topic
				// N.B. topicchild elements are added when parsing a LARGE file
				if (this.governed_max_depth > 0) {
					if (!has_child_topics) {
						html += '<h1>Governed Content</h1><ul>';
						has_child_topics = true;
					}
					html += `<li>${this.formatLink(node.getAttribute("topic_id"), node.getAttribute("public_name"))}${addDescendents(this.governed_max_depth-1, node.getAttribute("topic_id"))}</li>`;
				}
				break;
			case 'linkage':
				switch (node.getAttribute('direction')) {
				case 'Outbound': outbound.push(node); break;
				case 'Inbound' : inbound.push(node);  break;
				case 'Both'    : both.push(node);     break;
				}
				break;
			case 'connection':
				// <connection target_id="Topic_2" target_name="Child Feat 1" nature="Master_To_Minion" qualifier="Owner / Subsidiary"/>
				if (!has_connections) {
					has_connections = true;
					html += '<h1>Relationships</h1>';
				}
				html += '<p>';
				if (node.hasAttribute('qualifier'))
					html += `${node.getAttribute('qualifier')} `;
				html += `<i>(${node.getAttribute('nature').replace(/_/g,'-')})</i> `;
				html += `${this.formatLink(node.getAttribute('target_id'), node.getAttribute('target_name'))}`;
				if (node.hasAttribute('rating'))
					html += `, rating ${node.getAttribute('rating')}`;
				if (node.hasAttribute('attitude'))
					html += `, attitude ${node.getAttribute('attitude')}`;
				let note = node.getElementsByTagName('annotation');
				if (note.length > 0)
					html += ` (${note[0].textContent})`;
				break;
			}
			// and ignore tag_assign at this point.
		}
		if (has_child_topics) {
			html += '</ul>';
		}
		// Add inbound and/or outbound link information (if requested)
		if (this.addInboundLinks && (inbound.length > 0 || both.length > 0)) {
			html += '<h1>Content Links: In</h1><p>';
			for (const node of inbound) {
				html += this.formatLink(node.getAttribute("target_id"), node.getAttribute("target_name"));
			}
			for (const node of both) {
				html += this.formatLink(node.getAttribute("target_id"), node.getAttribute("target_name"));
			}
			html += '</p>';
		}
		if (this.addOutboundLinks && (outbound.length > 0 || both.length > 0)) {
			html += '<h1>Content Links: Out</h1><p>';
			for (const node of outbound) {
				html += this.formatLink(node.getAttribute("target_id"), node.getAttribute("target_name"));
			}
			for (const node of both) {
				html += this.formatLink(node.getAttribute("target_id"), node.getAttribute("target_name"));
			}
			html += '</p>';
		}

		// Full title might have prefix and suffix
		let journaltitle = topic.getAttribute("public_name");
		let prefix = topic.getAttribute('prefix');
		let suffix = topic.getAttribute('suffix');
		if (prefix) journaltitle = prefix + ' - ' + journaltitle;
		if (suffix) journaltitle += ' (' + suffix + ')';
		
		// Format as a data block usable by JournalEntry.update
		let result = {
			_id:      this.entity_for_topic[this_topic_id].data._id,
			name:     journaltitle,
			topic_id: this_topic_id,
			content:  html,
		};
		//console.debug(`Finished topic '${topic.getAttribute("public_name")}' in folder ${result.folder}`);
		
		return result;
	}

	// Examine each topic within topics to see if it should be converted into an actor:
	// i.e. it contains a Portfolio or Statblock snippet type directly, not in a child topic.
	getActorSnippets(node, onlyone=false) {
		let snippets=[];
		for (const child of node.children) {
			if (child.nodeName === 'snippet' && 
				(child.getAttribute('type') === 'Portfolio' || 
				 child.getAttribute('type') === 'Statblock')) {
				snippets.push(child);
				if (onlyone) break;
			} else if (child.children.length > 0 && child.nodeName !== 'topic' && child.nodeName !== 'topicchild') {
				// Don't check nested topics
				let result = this.getActorSnippets(child);
				if (result.length > 0) {
					snippets = snippets.concat(result);
					if (onlyone) break;
				}
			}
		}
		return snippets;
	}
	
	getActorTopics(topics) {
		// This should return an HTMLCollection
		let result = [];
		for (const topic of topics) {
			if (this.getActorSnippets(topic,/*onlyone*/true).length > 0) {
				result.push(topic);
			}
		}
		return result;
	}

	//
	// Convert a TOPIC into one or more Actors
	// @return an array containing 0 or more ActorData
	//
	async formatActors(topic) {
		//console.debug(`Formatting actor for ${topic.getAttribute('public_name')}`);
		let result = [];
		let topicname = topic.getAttribute('public_name');
		for (const snippet of this.getActorSnippets(topic)) {
			if (!snippet) {
				console.warn(`formatActors for '${topicname}':\n <snippet type=Portfolio|Statblock> is missing - Skipping`);
				continue;
			}

			const sntype = snippet.getAttribute('type');
			const ext_object = this.getChild(snippet, 'ext_object'); // <ext_object name="Portrait" type="Picture">
			if (!ext_object) {
				console.warn(`formatActors for '${topicname}':\n no <ext_object> for ${sntype} - Skipping`);
				continue;
			}
			const asset = this.getChild(ext_object, 'asset'); // <asset filename="10422561_10153053819388385_8373621707661700909_n.jpg">
			if (!asset) {
				console.warn(`formatActors for '${topicname}':\n no <asset> for ${sntype} with ${ext_object.getAttribute('type')} of ${ext_object.getAttribute('name')} - Skipping`);
				continue;
			}
			const contents = this.getChild(asset, 'contents'); // <contents>
			if (!contents) {
				console.warn(`formatActors for '${topicname}':\n no <contents> for ${sntype} with ${ext_object.getAttribute('type')} of ${ext_object.getAttribute('name')} - Skipping`);
				continue;
			}
			const filename = asset.getAttribute('filename');

			let statblock;
			let portfolio;
			if (sntype === 'Portfolio') {
				if (!filename.endsWith('.por')) {
					console.warn(`formatActors for '${topicname}':\n Portfolio file '${filename}' does not end with .por - Skipping`);
					continue;
				}
				//console.debug(`Reading portfolio ${filename}`);
				//portfolio = this.readPortfolio(contents.textContent);
				// Upload images (if any)
				portfolio = this.readPortfolio(contents.textContent);
				for (let[charname, character]of portfolio) {
					if (character.imgfilename) {
						await this.uploadBinaryFile(character.imgfilename, character.imgdata);
					}
				}
			} else { // (sntype === 'Statblock')
				if (!filename.endsWith('.html') && !filename.endsWith('.htm') && !filename.endsWith('.rtf') && !filename.endsWith('.txt')) {
					console.warn(`formatActors for '${topicname}':\n Statblock file '${filename}' does not end with .htm or .html or .rtf or .txt - Skipping`);
					continue;
				}
				console.debug(`formatActors for '${topicname}': reading statblock from ${filename}`);
				statblock = atob(contents.textContent);
			}

			// Call the ACTOR creator for the specific GAME SYSTEM that is installed
			//console.debug(`ACTOR ${topic.getAttribute('public_name')} = HTML '${html}'`);
			if (!this.parser)
				this.parser = new DOMParser();

			if (portfolio) {
				if (this.create_actor_data) {
					for (let [charname, character] of portfolio) {
						// The lack of XML will be because this is a MINION of another character.
						if (character.xml) {
							const json = RealmWorksImporter.xmlToObject(this.parser.parseFromString(this.Utf8ArrayToStr(character.xml), "text/xml"));
							await this.create_actor_data(json.document.public.character)
							.then(actorlist => {
								for (let actor of actorlist) {
									// actor really is the full Actor, not just ActorData
									// Cater for MINIONS
									let port = portfolio.get(actor.name);
									actor.token = {
										disposition: actor.relationship === 'ally' ? 1 : actor.relationship === 'enemy' ? -1 : 0
									};
									actor.data = foundry.utils.mergeObject(actor.data, this.actor_data_func(this.Utf8ArrayToStr(port.html)));
									if (port?.imgfilename)
										actor.img = this.imageFilename(port.imgfilename);
									result.push(actor);
								}
							})
							.catch(e => console.warn(`createActorData for '${character.name}' in '${topicname}':\nFailed in ${filename} due to ${e}`));
						}
					}
				} else {
					// All other game systems use this.actor_data_func to create the correct basic data block
					for (let [charname, character] of portfolio) {
						// TODO - XML conversion
						let actor = {
							name: character.name,
							type: this.actor_type,
							data: this.actor_data_func(this.Utf8ArrayToStr(character.html)),
						};
						if (character.imgfilename)
							actor.img = this.imageFilename(character.imgfilename)
								result.push(actor);
					}
				}
			} else {
				// No portfolio file available for decoding, so simply store the STATBLOCK in the relevant location on the Actor
				let name = ext_object.getAttribute('name');
				const annotation = this.getChild(snippet, 'annotation');
				if (annotation) name += ':' + this.stripHtml(annotation.textContent);
				let actor = {
					name: name,
					type: this.actor_type,
					data: this.actor_data_func(statblock),
				};
				result.push(actor);
			}
		}
		// If there is only more than one actor in the topic,
		// or the name of the actor does NOT match the name of the topic,
		// then put the actors in a sub-folder named after the topic.
		if (result.length === 0) return result;
		let topic_name = topic.getAttribute('public_name');
		let folderid = (result.length === 1 && result[0].name === topic_name) ? this.actor_folder.id : (await this.getFolder(topic_name, 'Actor', this.actor_folder.id)).id;

		// Set the folder for each actor.
		for (let i=0; i<result.length; i++)
			result[i].folder = folderid;
		//console.debug(`Actor data for ${actor.name} in folder ${actor.folder}`);
		
		return result;
	}
	
	//
	// Create a PLAYLIST for each topic, containing all AUDIO snippets from that topic
	//
	
	async createPlaylists(topics) {
		// Find all Audio snippets
		let snippets;
		function getSoundSnippets(node) {
			for (const child of node.children) {
				if (child.nodeName === 'snippet' && child.getAttribute('type') === 'Audio') {
					snippets.push(child);
				} else if (child.nodeName !== 'topic' && child.nodeName !== 'topicchild' && child.children.length > 0) {
					// Don't check nested topics
					getSoundSnippets(child);
				}
			}
		}

		// Write out sounds that we find, as a playlist named after the topic.
		for (const topic of topics) {
			snippets = [];
			getSoundSnippets(topic);
			if (snippets.length === 0) continue;

			let playlist = {
				name: topic.getAttribute('public_name'),
				description: "",
				//	"mode": 0,
				//	"playing": false,
				//	"sort": 0,
				//	"seed": 840,
				sounds: [],
				folder: this.playlist_folder?.id,
			};
			
			// Sound file has already been uploaded
			for (const snippet of snippets) {
				const ext_object = this.getChild(snippet,    'ext_object'); 
				const asset      = this.getChild(ext_object, 'asset');
				const filename = asset?.getAttribute('filename');
				if (!this.getChild(asset, 'contents')) continue;		// No contents means no file!
				// ext_object.getAttribute('type') === 'Audio'
				
				let name = ext_object.getAttribute('name');
				if (name === 'Audio File') {
					// The default name is boring, find a better one
					let last = filename.lastIndexOf('.');
					name = (last > 0) ? filename.slice(0,last) : filename;
				}
				
				let sound = {
					name: name,
					path: this.imageFilename(filename),		// including path
					description: "",
					//	"playing": false,
					//	"pausedTime": null,
					//	"repeat": false,
					//	"volume": 0.5,
					//	"flags": {},
				};
				
				const annotation = this.getChild(snippet, 'annotation');
				if (annotation) sound.description = this.stripHtml(annotation.textContent);
				
				playlist.sounds.push(sound);
			}
			await Playlist.create(playlist);
		}
	}
	
	//
	// Read a HeroLab portfolio file and create Actors directly from the contents
	//
	async parseHL(file)
	{
		let data = await file.arrayBuffer();
		if (!data) throw "Failed to read .por file";
		
		if (this.init_actors) {
			await this.init_actors();
		}

		// Maybe delete old items
		if (this.deleteOldFolders) {
			// Delete folders with the given name.
			for (let folder of game.folders.filter(e => e.type === 'Actor' && e.name === this.folderName)) {
				await folder.delete({
					deleteSubfolders: true,
					deleteContents: true
				});
			}
		}

		let actor_folder_id = (await this.getFolder(this.folderName, 'Actor')).id;
		
		// Create the image folder if it doesn't already exist.
		await DirectoryPicker.verifyPath(DirectoryPicker.parse(this.asset_directory));

		if (!this.parser) this.parser = new DOMParser();
		let portfolio = this.readPortfolio(new Uint8Array(data));
		let actors = [];
		// Upload images (if any)
		for (let [charname, character] of portfolio) {
			if (this.create_actor_data) {
				// no XML means it is a MINION, and has been created from the XML of another character.
				if (character.xml) {
					const json = RealmWorksImporter.xmlToObject(this.parser.parseFromString(this.Utf8ArrayToStr(character.xml), "text/xml"));
					const actorlist = await this.create_actor_data(json.document.public.character);

					for (let actordata of actorlist) {
						// Minion will have ITS data in a different place in the portfolio.
						let port = portfolio.get(actordata.name);

						// Store the raw statblock (but don't overwrite the rest of data)
						actordata.data = foundry.utils.mergeObject(actordata.data, this.actor_data_func(this.Utf8ArrayToStr(port.html)));
						actordata.token = {
							disposition: actordata.relationship === 'ally' ? 1 : actordata.relationship === 'enemy' ? -1 : 0
						};
						actordata.folder = actor_folder_id;
						if (port.imgfilename) {
							// If we don't "await", then Actor.create will fail since the image doesn't exist
							await this.uploadBinaryFile(port.imgfilename, port.imgdata);
							actordata.img = this.imageFilename(port.imgfilename);
						}
						// Delete any existing actor with the same name
						//let existing = game.actors.contents.find(o => o.name === actordata.name);
						//if (existing) await existing.delete();
						actors.push(actordata);
					}
				}
			} else if (character.html) {
				// Not supported for system-specific actor creation, so just put in the HTML
				let actordata = {
					name: character.name,
					type: this.actor_type,
					data: this.actor_data_func(this.Utf8ArrayToStr(character.html)),
					folder: actor_folder_id,
				};
				if (character.imgfilename)
					actordata.img = this.imageFilename(character.imgfilename)
				actors.push(actordata);
			}
		}
		if (actors.length > 0) await Actor.create(actors)
			.catch(e => console.warn(`Failed to create Actors due to ${e}`));

	}
	
	//
	// Parse the entire Realm Works file supplied in 'xmlString'
	// and extract each element into relevant areas of the world DB
	//
	async parseXML(topics, parent_map, child_map)
	{
		let category_names = new Set();
		for (const topic of topics)  {
			category_names.add(topic.getAttribute('category_name'));
		}

		// Maybe delete the old folders before creating a new one?
		if (this.deleteOldFolders) {
			// Delete folders with the given name.
			for (let folder of game.folders.filter(e => e.name === this.folderName)) {
				await folder.delete({
					deleteSubfolders: true,
					deleteContents: true
				});
			}
		}

		// Create the folders now
		console.info('Creating folders');
		this.actor_folder    = await this.getFolder(this.folderName, 'Actor');
		this.scene_folder    = await this.getFolder(this.folderName, 'Scene');
		this.playlist_folder = await this.getFolder(this.folderName, 'Playlist');
		let journal_parent   = await this.getFolder(this.folderName, 'JournalEntry');
		let journal_folders  = new Map();  // actual journal entries will be in a folder with the TOPIC category name
		for (const category_name of category_names) {
			await this.getFolder(category_name, 'JournalEntry', journal_parent.id)
				.then(folder => journal_folders.set(category_name, folder))
				.catch(err => console.warn(`Failed to create Journal folder for ${category_name} due to ${err}`));
		}
		// Create the image folder if it doesn't already exist.
		await DirectoryPicker.verifyPath(DirectoryPicker.parse(this.asset_directory));
		// Create a mapping from topic_id to public_name for all topic elements, required for creating "@JournalEntry["mapping[linkage:target_id]"]{"linkage:target_name"}" entries.
		// Also collect aliases for each topic:
		// <alias alias_id="Alias_1" name="Barracks Emperors" />
		this.topic_names = new Map();
		for (const child of topics) {
			const topic_name = child.getAttribute("public_name");
			//console.debug(`Found topic '${child.getAttribute("topic_id")}' with name '${topic_name}'`);
			let names = new Array();
			names.push(topic_name);
			
			for (const subchild of child.children) {
				if (subchild.nodeName === "alias") {
					names.push(subchild.getAttribute('name'));
				}
			};
			this.topic_names.set(child.getAttribute("topic_id"), names);
		};

		//
		// TOPICS => JOURNAL ENTRIES
		//
		// Generate empty topic entries first, so that we have Foundry id's for each topic.
		this.ui_message.val(`Creating ${topics.length} empty journal entries`);
		console.info(`Creating ${topics.length} empty journal entries`);
		
		this.entity_for_topic = new Map();
		await Promise.allSettled(topics.map(async(topic) => {
				return {
					topic_id: topic.getAttribute("topic_id"),
					topic: await JournalEntry.create({
						name: topic.getAttribute('public_name'),
						folder: journal_folders.get(topic.getAttribute('category_name')).id,
					}),
				}
			}))
		// Now add all valid entries to entity_for_topic synchronously
		.then(results => results.forEach(result => {
				if (result.status === 'fulfilled')
					this.entity_for_topic[result.value.topic_id] = result.value.topic;
			}));
		// Asynchronously generate each of the Journal Entries
		this.ui_message.val(`Generating ${topics.length} journal contents`);
		console.info(`Generating ${topics.length} journal contents`);
		await Promise.allSettled(topics.map(async(topic_node) =>
				await this.formatOneTopic(topic_node, child_map, parent_map.get(topic_node.getAttribute('topic_id')))
				.then(async(topic) => {
					await JournalEntry.updateDocuments([topic]).catch(p => console.warn(`Update JE failed for '${topic.name}':\n${p}`));
				})
				.catch(e => console.warn(`formatOneTopic failed for ${topic_node.getAttribute("public_name")}:\n${e}`))));
		//
		// HL PORTFOLIOS => ACTORS
		//

		if (this.init_actors) {
			await this.init_actors();
		}

		console.debug('Finding Topics with Actors');
		let actor_topics = this.getActorTopics(topics);
		this.ui_message.val(`Generating ${actor_topics.length} Actors`);
		console.info(`Generating actors from ${actor_topics.length} Topics`);

		// Asynchronously get the data for all the actors,
		// don't CREATE the Actors until we've had a chance to remove duplicates
		// TODO: if actors.length > 1 then put them inside a folder named after the topic.
		await Promise.allSettled(actor_topics.map(async(topic_node) =>
				await this.formatActors(topic_node)
				.then(async(actors) => await Actor.create(actors))
				.catch(error => console.warn(`formatActors for topic '${topic_node.getAttribute("public_name")}': ${error}`))))

		// AUDIO snippets => PLAYLISTS
		this.ui_message.val(`Generating playlists`);
		console.info(`Generating playlists`);
		await this.createPlaylists(topics);
		
		// Tidy up "this" - hopefully recovering some memory before the next run.
		delete this.actor_folder;
		delete this.scene_folder;
		delete this.playlist_folder;
		delete this.topic_names;
		delete this.entity_for_topic;
	}
} // class
